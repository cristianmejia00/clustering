height = 6, # Height in inches
dpi = 300   # Resolution (dots per inch)
)
# PY Z9 plots
for (inst in unique(tmp$dataset)) {
print(inst)
p <- plot_scatter(tmp %>% filter(dataset == inst),
point_labels = "scatter_labels",
x_column = "PY_Mean",
y_column = "Z9_Mean",
color_hex_column = "color",
color_labels = "dataset",
size_column = "documents",
min_x = min(tmp$PY_Mean, na.rm = TRUE) %>% floor(),
max_x = max(tmp$PY_Mean, na.rm = TRUE) %>% ceiling(),
max_y = max(tmp$Z9_Mean, na.rm = TRUE) %>% ceiling(),
show_tags = TRUE)
ggsave(
filename = file.path(
bibliometrics_folder_path,
settings$metadata$heatmap_analysis_id,
paste("scatter_plot_", inst, ".png", sep = "")),
plot = p,
width = 8,  # Width in inches
height = 6, # Height in inches
dpi = 300   # Resolution (dots per inch)
)
}
# Heatmap
hm <- readr::read_csv(file.path(
bibliometrics_folder_path,
settings$metadata$heatmap_analysis_id,
"heatmap_matrix.csv"
)) %>% as.data.frame()
rownames(hm) <- colnames(hm)
# Create a sorting vector
sort_vector <- sort(colnames(hm))
# Sort the heatmap
hm_sorted <- hm[sort_vector, sort_vector]
# Convert matrix to long format for ggplot
df_long <- hm_sorted %>% as.matrix() %>% melt()
# Create heatmap
tm_hm <- ggplot(df_long, aes(x = Var1, y = Var2, fill = value)) +
geom_tile() +
scale_fill_gradient(low = "white", high = "red") +
theme_minimal() +
coord_fixed() +  # make cells square
labs(x = "", y = "", fill = "Similarity") +  # label axes
theme(axis.text.x = element_text(angle = 45, hjust = 1))  # rotate x labels for better readability
tm_hm
ggsave(
plot = tm_hm,
filename = file.path(
bibliometrics_folder_path,
settings$metadata$heatmap_analysis_id,
"heatmap.png"),
width = 8,  # Width in inches
height = 6, # Height in inches
dpi = 300   # Resolution (dots per inch)
)
# Sankey
melted <- readr::read_csv(file.path(
bibliometrics_folder_path,
settings$metadata$heatmap_analysis_id,
"heatmap_melted.csv"
))
melted$Source <- gsub("Sut", "Sust", melted$Source)
melted$Target <- gsub("Sut", "Sust", melted$Target)
melted <- melted %>%
separate(Source,
remove = FALSE,
into = c("source_dataset", "source_local_cluster"),
sep = "-") %>%
separate(Target,
remove = FALSE,
into = c("target_dataset", "target_local_cluster"),
sep = "-")
melted <- merge(melted,
inputs %>%
select(display_name, color, heatmap_display_order, sankey_display_order) %>%
rename(source_color = color,
source_heatmap_order = heatmap_display_order,
source_sankey_order = sankey_display_order),
by.x = "source_dataset",
by.y = "display_name",
all.x = TRUE,
all.y = FALSE)
melted <- merge(melted,
inputs %>%
select(display_name, color, heatmap_display_order, sankey_display_order) %>%
rename(target_color = color,
target_heatmap_order = heatmap_display_order,
target_sankey_order = sankey_display_order),
by.x = "target_dataset",
by.y = "display_name")
###############################################################################
png(filename = file.path(
bibliometrics_folder_path,
settings$metadata$heatmap_analysis_id,
"similarity_boxplot.png"))
bp <- boxplot(melted$Similarity, ylab = "Similarity")
dev.off()
bp$stats
###############################################################################
sankey_threshold <- bp$stats[3,1] #settings$global$sankey_threshold
melted_filtered <- melted %>%
filter(source_sankey_order != target_sankey_order) %>%
#filter(abs(source_sankey_order - target_sankey_order) == 1) %>%
filter(Similarity >= sankey_threshold)
sankey_steps <- unique(inputs$sankey_display_order) %>% sort()
# Stacking the datasets to reorder them
melted_filtered$pair_index <- c(1:nrow(melted_filtered)) %>% as.character()
sources_df <- lapply(sankey_steps, \(st) {
tmp <- melted_filtered %>%
filter(source_sankey_order == st) %>%
select(Source, source_sankey_order, Similarity, pair_index) %>%
rename(cluster = Source,
step = source_sankey_order,
similarity = Similarity)
}) %>% rbind.fill()
targets_df <- lapply(sankey_steps, \(st) {
tmp <- melted_filtered %>%
filter(target_sankey_order == st) %>%
select(Target, target_sankey_order, Similarity, pair_index) %>%
rename(cluster = Target,
step = target_sankey_order,
similarity = Similarity)
}) %>% rbind.fill()
melted_listed <- rbind(sources_df, targets_df)
###############################################################################
melted_sankey <- lapply(c(0, max(sankey_steps) - 1), function(st) {
left_side <- melted_listed %>%
filter(step == st)
right_side <- melted_listed %>%
filter(step > st) # filter(step == st + 1) when strictly step by step
full_pair <- merge(left_side %>%
select(cluster, step, similarity, pair_index) %>%
rename(Source = cluster, "Step from" = step, source_similarity = similarity),
right_side %>%
select(cluster, step, similarity, pair_index) %>%
rename(Dest = cluster, "Step to" = step, dest_similarity = similarity),
by = "pair_index",
all.x = FALSE,
all.y = FALSE)
}) %>%
rbind.fill() %>%
select(all_of(c("Source", "Dest", "source_similarity", "Step from", "Step to"))) %>%
rename(Similarity = source_similarity) %>%
mutate(Value = 100,
Distance = `Step to` - `Step from`) %>%
arrange(Distance, `Step from`, desc(Similarity))
###############################################################################
melted_sankey_topics <- merge(melted_sankey,
rcs %>%
select(cluster_code, cluster_name) %>%
rename(source_topic = cluster_name),
by.x = 'Source',
by.y = 'cluster_code',
all.x = TRUE,
all.y = FALSE)
melted_sankey_topics <- merge(melted_sankey_topics,
rcs %>%
select(cluster_code, cluster_name) %>%
rename(target_topic = cluster_name),
by.x = 'Dest',
by.y = 'cluster_code',
all.x = TRUE,
all.y = FALSE)
melted_sankey_topics <- melted_sankey_topics %>%
select(all_of(c("Source", "Dest", "Value", "Step from", "Step to", "Similarity", "Distance", "source_topic", "target_topic"))) %>%
arrange(`Step from`, Source, desc(Similarity)) %>%
distinct(Source, Dest, .keep_all = TRUE) %>%
mutate(
'Value' = map_to_range(Value, 100, 10)
)
# Save files
write.csv(melted_sankey_topics,
file=file.path(bibliometrics_folder_path,
settings$metadata$heatmap_analysis_id,
glue('sankey_df_with_deadends_{round(sankey_threshold, 2)}_selected.csv')),
row.names = FALSE)
###############################################################################
# Write color codes for Flourish
write.csv(paste(tmp$cluster_code, tmp$color, sep = ': '),
file=file.path(bibliometrics_folder_path,
settings$metadata$heatmap_analysis_id,
'sankey_cluster_color_for_flourish.csv'),
row.names = FALSE)
###############################################################################
# Hardcoded!
bridge_clusters <-intersect(
melted_sankey$Dest[melted_sankey$`Step to` == 1],
melted_sankey$Source[melted_sankey$`Step from` == 1]
)
if (length(bridge_clusters) > 0) {
melted_bridge <- melted_sankey %>%
filter(`Step to` != 1 | Dest %in% bridge_clusters) %>%
filter(`Step from` != 1 | Source %in% bridge_clusters)
write.csv(melted_bridge,
file=file.path(bibliometrics_folder_path,
settings$metadata$heatmap_analysis_id,
'sankey_df_without_deadends.csv'),
row.names = FALSE)
# Readable
left_side <- melted_bridge %>% filter(`Step to` == 1)
right_side <- melted_bridge %>% filter(`Step from` == 1)
melted_bridge_readable <- merge(left_side %>%
select(Source, Dest) %>%
rename(left = Source, bridge = Dest),
right_side %>%
select(Source, Dest) %>%
rename(right = Dest, bridge = Source),
by = "bridge",
all.x = TRUE,
all.y = TRUE)
# Add topics
melted_bridge_readable$left_topic <- rcs$cluster_name[match(melted_bridge_readable$left, rcs$cluster_code)]
melted_bridge_readable$bridge_topic <- rcs$cluster_name[match(melted_bridge_readable$bridge, rcs$cluster_code)]
melted_bridge_readable$right_topic <- rcs$cluster_name[match(melted_bridge_readable$right, rcs$cluster_code)]
# Arrange columns
melted_bridge_readable <- melted_bridge_readable %>% select(left, bridge, right, left_topic, bridge_topic, right_topic)
write.csv(melted_bridge_readable,
file=file.path(bibliometrics_folder_path,
settings$metadata$heatmap_analysis_id,
'sankey_df_without_deadends_readable.csv'),
row.names = FALSE)
}
# 2024-11-18
# Code to plot a Sankey directly in Rstudo.
# This codes depends on `04_Analyze_after_colab_TM_v3.R`...
# Meaning that we must run it after it.
# This code:
# Plots the Sanky in RStudio
# Saves the plot as an HTML widget
# Colors the edges by the target cluster color (Gradients are not possible yet)
# Displays a max of 50 paths.
# We need two inputs from that environment:
# - `melted_sankey_topics`: the final data frame with the paths
# - `inputs`: the dataframe with the display names and colors as assigned in settings
# Load required libraries
library(dplyr)
library(networkD3)
library(htmlwidgets)
library(RColorBrewer)
library(readr)
# Read the data
data <- melted_sankey_topics #
# Filters
# Retain upto 50
data <- data %>% top_n(50, wt=Similarity)
# Remove 'others'
data<- data %>%
filter(!grepl("99---|99$", Source)) %>%
filter(!grepl("99---|99$", Dest))
# Remove dashes
data$Source <- gsub("---", ": ", data$Source)
data$Dest <- gsub("---", ": ", data$Dest)
# Prepare names
data$Source <- paste(data$Source, data$source_topic)
data$Dest <- paste(data$Dest, data$target_topic)
# Create nodes dataframe
# Get unique nodes from both source and destination
nodes <- unique(c(data$Source, data$Dest))
nodes_group <- sapply(nodes, \(x) {unlist(strsplit(x, "-"))[[1]]})
nodes_dn <- paste0("'", inputs$display_name, "'", collapse = ", ")
nodes_cl <- paste0("'", inputs$color, "'", collapse = ", ")
nodes_df <- data.frame(
name = nodes,
node_group = factor(nodes_group)
)
# Create links dataframe
links_df <- data.frame(
source = match(data$Source, nodes_df$name) - 1,  # 0-based indexing
target = match(data$Dest, nodes_df$name) - 1,
value = data$Value
)
links_df$link_group <- nodes_df[links_df$target + 1, 'node_group']
# Create custom color scale
my_color_scale <- JS(sprintf(
glue("d3.scaleOrdinal()
.domain([{nodes_dn}])
.range([{nodes_cl}])")
))
# Create Sankey diagram
sankey <- sankeyNetwork(
Links = links_df,
Nodes = nodes_df,
Source = "source",
Target = "target",
Value = "value",
NodeID = "name",
NodeGroup = "node_group",
LinkGroup = "link_group",
colourScale = my_color_scale,
fontSize = 11,
nodeWidth = 25,
nodePadding = 10,
height = 600,
width = 1100,
sinksRight = FALSE
)
# Display the Sankey in R
sankey
# Save the widget
saveWidget(sankey,
file=file.path(bibliometrics_folder_path,
settings$metadata$heatmap_analysis_id,
"sankey_diagram.html"),
selfcontained = TRUE)
# # Tests for gradient edges
# sankey <- htmlwidgets::onRender(
#   sankey,
#   '
#   function(el, x) {
#     // Color scales for each group
#     const nodeColors = {
#       group1: "#E67E22",  // Orange for PIK
#       group2: "#82E0AA",  // Green for Plant
#       group3: "#5DADE2"   // Blue for RIKEN
#     };
#
#     // Create gradient definitions
#     const svg = d3.select(el).select("svg");
#     const defs = svg.append("defs");
#
#     // Create gradient for each link
#     d3.select(el).selectAll(".link").each(function(d) {
#       const gradientID = `gradient-${d.source.index}-${d.target.index}`;
#
#       // Determine source and target colors based on node groups
#       const sourceColor = nodeColors[d.source.node_group];
#       const targetColor = nodeColors[d.target.node_group];
#
#       // Create gradient definition
#       const gradient = defs.append("linearGradient")
#         .attr("id", gradientID)
#         .attr("gradientUnits", "userSpaceOnUse")
#         .attr("x1", d.source.x1)
#         .attr("x2", d.target.x0);
#
#       // Add gradient stops
#       gradient.append("stop")
#         .attr("offset", "0%")
#         .attr("stop-color", sourceColor);
#
#       gradient.append("stop")
#         .attr("offset", "100%")
#         .attr("stop-color", targetColor);
#
#       // Apply gradient to link
#       d3.select(this)
#         .style("stroke", `url(#${gradientID})`)
#         .style("opacity", 0.7);
#     });
#
#     // Customize node labels
#     d3.select(el)
#       .selectAll(".node text")
#       .style("font-weight", "bold")
#       .style("fill", "black")
#       .attr("x", function(d) {
#         return d.x0 < width / 2 ? 6 + sankey.nodeWidth() : -6;
#       })
#       .attr("text-anchor", function(d) {
#         return d.x0 < width / 2 ? "start" : "end";
#       });
#   }
#   '
# )
# 2024-11-18
# Code to plot a Sankey directly in Rstudo.
# This codes depends on `04_Analyze_after_colab_TM_v3.R`...
# Meaning that we must run it after it.
# This code:
# Plots the Sanky in RStudio
# Saves the plot as an HTML widget
# Colors the edges by the target cluster color (Gradients are not possible yet)
# Displays a max of 50 paths.
# We need two inputs from that environment:
# - `melted_sankey_topics`: the final data frame with the paths
# - `inputs`: the dataframe with the display names and colors as assigned in settings
# Load required libraries
library(dplyr)
library(networkD3)
library(htmlwidgets)
library(RColorBrewer)
library(readr)
# Read the data
data <- melted_sankey_topics #
# Filters
# Retain upto 50
data <- data %>% top_n(100, wt=Similarity)
# Remove 'others'
data<- data %>%
filter(!grepl("99---|99$", Source)) %>%
filter(!grepl("99---|99$", Dest))
# Remove dashes
data$Source <- gsub("---", ": ", data$Source)
data$Dest <- gsub("---", ": ", data$Dest)
# Prepare names
data$Source <- paste(data$Source, data$source_topic)
data$Dest <- paste(data$Dest, data$target_topic)
# Create nodes dataframe
# Get unique nodes from both source and destination
nodes <- unique(c(data$Source, data$Dest))
nodes_group <- sapply(nodes, \(x) {unlist(strsplit(x, "-"))[[1]]})
nodes_dn <- paste0("'", inputs$display_name, "'", collapse = ", ")
nodes_cl <- paste0("'", inputs$color, "'", collapse = ", ")
nodes_df <- data.frame(
name = nodes,
node_group = factor(nodes_group)
)
# Create links dataframe
links_df <- data.frame(
source = match(data$Source, nodes_df$name) - 1,  # 0-based indexing
target = match(data$Dest, nodes_df$name) - 1,
value = data$Value
)
links_df$link_group <- nodes_df[links_df$target + 1, 'node_group']
# Create custom color scale
my_color_scale <- JS(sprintf(
glue("d3.scaleOrdinal()
.domain([{nodes_dn}])
.range([{nodes_cl}])")
))
# Create Sankey diagram
sankey <- sankeyNetwork(
Links = links_df,
Nodes = nodes_df,
Source = "source",
Target = "target",
Value = "value",
NodeID = "name",
NodeGroup = "node_group",
LinkGroup = "link_group",
colourScale = my_color_scale,
fontSize = 11,
nodeWidth = 25,
nodePadding = 10,
height = 600,
width = 1100,
sinksRight = FALSE
)
# Display the Sankey in R
sankey
# Save the widget
saveWidget(sankey,
file=file.path(bibliometrics_folder_path,
settings$metadata$heatmap_analysis_id,
"sankey_diagram.html"),
selfcontained = TRUE)
# # Tests for gradient edges
# sankey <- htmlwidgets::onRender(
#   sankey,
#   '
#   function(el, x) {
#     // Color scales for each group
#     const nodeColors = {
#       group1: "#E67E22",  // Orange for PIK
#       group2: "#82E0AA",  // Green for Plant
#       group3: "#5DADE2"   // Blue for RIKEN
#     };
#
#     // Create gradient definitions
#     const svg = d3.select(el).select("svg");
#     const defs = svg.append("defs");
#
#     // Create gradient for each link
#     d3.select(el).selectAll(".link").each(function(d) {
#       const gradientID = `gradient-${d.source.index}-${d.target.index}`;
#
#       // Determine source and target colors based on node groups
#       const sourceColor = nodeColors[d.source.node_group];
#       const targetColor = nodeColors[d.target.node_group];
#
#       // Create gradient definition
#       const gradient = defs.append("linearGradient")
#         .attr("id", gradientID)
#         .attr("gradientUnits", "userSpaceOnUse")
#         .attr("x1", d.source.x1)
#         .attr("x2", d.target.x0);
#
#       // Add gradient stops
#       gradient.append("stop")
#         .attr("offset", "0%")
#         .attr("stop-color", sourceColor);
#
#       gradient.append("stop")
#         .attr("offset", "100%")
#         .attr("stop-color", targetColor);
#
#       // Apply gradient to link
#       d3.select(this)
#         .style("stroke", `url(#${gradientID})`)
#         .style("opacity", 0.7);
#     });
#
#     // Customize node labels
#     d3.select(el)
#       .selectAll(".node text")
#       .style("font-weight", "bold")
#       .style("fill", "black")
#       .attr("x", function(d) {
#         return d.x0 < width / 2 ? 6 + sankey.nodeWidth() : -6;
#       })
#       .attr("text-anchor", function(d) {
#         return d.x0 < width / 2 ? "start" : "end";
#       });
#   }
#   '
# )
View(data)
