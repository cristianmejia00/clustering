# Fix X-axis labels (Remove the hidden 'Group_' prefix we added for sorting)
scale_x_discrete(labels = function(x) sub(".*_", "", x)) +
# Labels and Theme
labs(y = "(Top 10% / Total) / (SI + SE Top 10% / SI + SE Total)", x = "") +
theme_bw() +
theme(
# Panel titles (Strip)
strip.background = element_rect(fill = "white", color = NA),
strip.text = element_text(face = "bold", size = 10, hjust = 0),
# Grid lines (Horizontal mainly, lighter vertical)
panel.grid.major.x = element_line(color = "gray95"),
panel.grid.major.y = element_line(color = "gray85"),
panel.grid.minor = element_blank(),
# Axis Text
axis.text.x = element_text(angle = 45, hjust = 1, size = 9, color = "black"),
axis.title = element_text(size = 9, face = "bold"),
# Legend
legend.position = "none" # Hidden as requested by visual match
) +
# Expand Y axis slightly to fit the labels on top
scale_y_continuous(expand = expansion(mult = c(0, 0.15)))
# Display
print(p)
library(ggplot2)
library(dplyr)
# 1. Exact Data Entry
# Values extracted directly from the labels in the high-res image
data <- bind_rows(
# Space Group
data.frame(Group = "Space", Category = "MII + ME",   Value = 2.05),
data.frame(Group = "Space", Category = "MID + ME",    Value = 1.35),
data.frame(Group = "Space", Category = "MII + SE",   Value = 1.29),
data.frame(Group = "Space", Category = "SI + ME", Value = 1.12),
data.frame(Group = "Space", Category = "SI + SE",  Value = 1.00),
data.frame(Group = "Space", Category = "MID + SE",  Value = 0.88),
# AI Group
data.frame(Group = "AI", Category = "MII + ME",   Value = 2.47),
data.frame(Group = "AI", Category = "MII + SE",   Value = 2.04),
data.frame(Group = "AI", Category = "MID + ME",    Value = 1.51),
data.frame(Group = "AI", Category = "SI + ME", Value = 1.44),
data.frame(Group = "AI", Category = "MID + SE",  Value = 1.27),
data.frame(Group = "AI", Category = "SI + SE",  Value = 1.00),
# Sustainability Group
data.frame(Group = "Sustainability", Category = "MII + ME",   Value = 2.10),
data.frame(Group = "Sustainability", Category = "MII + SE",   Value = 1.49),
data.frame(Group = "Sustainability", Category = "MID + SE",  Value = 1.27),
data.frame(Group = "Sustainability", Category = "MID + ME",    Value = 1.20),
data.frame(Group = "Sustainability", Category = "SI + ME", Value = 1.01),
data.frame(Group = "Sustainability", Category = "SI + SE",  Value = 1.00),
# Management Group
data.frame(Group = "Management", Category = "MII + ME",   Value = 1.73),
data.frame(Group = "Management", Category = "MII + SE",   Value = 1.50),
data.frame(Group = "Management", Category = "MID + ME",    Value = 1.29),
data.frame(Group = "Management", Category = "MID + SE",  Value = 1.10),
data.frame(Group = "Management", Category = "SI + SE",  Value = 1.00),
data.frame(Group = "Management", Category = "SI + ME", Value = 0.97),
# Quantum Group
data.frame(Group = "Quantum", Category = "MII + ME",   Value = 1.99),
data.frame(Group = "Quantum", Category = "MID + ME",    Value = 1.60),
data.frame(Group = "Quantum", Category = "MII + SE",   Value = 1.52),
data.frame(Group = "Quantum", Category = "MID + SE",  Value = 1.31),
data.frame(Group = "Quantum", Category = "SI + ME", Value = 1.26),
data.frame(Group = "Quantum", Category = "SI + SE",  Value = 1.00),
# Wellbeing Group
data.frame(Group = "Wellbeing", Category = "MII + ME",   Value = 1.49),
data.frame(Group = "Wellbeing", Category = "MII + SE",   Value = 1.44),
data.frame(Group = "Wellbeing", Category = "MID + ME",    Value = 1.24),
data.frame(Group = "Wellbeing", Category = "SI + ME", Value = 1.12),
data.frame(Group = "Wellbeing", Category = "SI + SE",  Value = 1.00),
data.frame(Group = "Wellbeing", Category = "MID + SE",  Value = 0.88)
)
# 2. Logic to Sort Bars Independently Per Panel
# We set the Group order first so the panels appear in the correct grid positions
data$Group <- factor(data$Group, levels = c("Space", "AI", "Sustainability",
"Management", "Quantum", "Wellbeing"))
# We create a combined column (Group + Category).
# We then order this column based on the Value (descending).
# This "tricks" ggplot into sorting every panel individually.
data <- data %>%
arrange(Group, desc(Value)) %>%
mutate(Unique_Bar_ID = factor(paste(Group, Category, sep="_"),
levels = paste(Group, Category, sep="_")))
# 3. Define Exact Colors
custom_colors <- c(
"MII + ME"   = "#2ca02c",  # Green
"MII + SE"   = "#d62728",  # Red
"MID + ME"    = "#1f77b4",  # Blue
"MID + SE"  = "#ff7f0e",  # Orange
"SI + ME" = "#9467bd",  # Purple
"SI + SE"  = "#8c564b"   # Brown
)
# 4. Create the Plot
p <- ggplot(data, aes(x = Unique_Bar_ID, y = Value, fill = Category)) +
geom_bar(stat = "identity", width = 0.7) +
# Labels on top of bars
geom_text(aes(label = paste0(format(Value, nsmall=2), "x")),
vjust = -0.4,
size = 2.8,
fontface = "bold") +
# Create the 2x3 Grid
facet_wrap(~ Group, scales = "free_x", ncol = 3) +
# Apply Colors
scale_fill_manual(values = custom_colors) +
# Fix X-axis labels (Remove the hidden 'Group_' prefix we added for sorting)
scale_x_discrete(labels = function(x) sub(".*_", "", x)) +
# Labels and Theme
labs(y = "(Top 10% / Total) / (SI + SE Top 10% / SI + SE Total)", x = "") +
theme_bw() +
theme(
# Panel titles (Strip)
strip.background = element_rect(fill = "white", color = NA),
strip.text = element_text(face = "bold", size = 10, hjust = 0),
# Grid lines (Horizontal mainly, lighter vertical)
panel.grid.major.x = element_line(color = "gray95"),
panel.grid.major.y = element_line(color = "gray85"),
panel.grid.minor = element_blank(),
# Axis Text
axis.text.x = element_text(angle = 45, hjust = 1, size = 9, color = "black"),
axis.title = element_text(size = 9, face = "bold"),
# Legend
legend.position = "none" # Hidden as requested by visual match
) +
# Expand Y axis slightly to fit the labels on top
scale_y_continuous(expand = expansion(mult = c(0, 0.15)))
# Display
print(p)
library(ggplot2)
library(dplyr)
# 1. Exact Data Entry
# Values extracted directly from the labels in the high-res image
data <- bind_rows(
# Space Group
data.frame(Group = "Space", Category = "MII + ME",   Value = 62.9),
data.frame(Group = "Space", Category = "MID + ME",    Value = 20.2),
data.frame(Group = "Space", Category = "MII + SE",   Value = 13.6),
data.frame(Group = "Space", Category = "SI + ME", Value = 18.2),
data.frame(Group = "Space", Category = "SI + SE",  Value = 0.00),
data.frame(Group = "Space", Category = "MID + SE",  Value = -11.42),
# AI Group
data.frame(Group = "AI", Category = "MII + ME",   Value = 99.3),
data.frame(Group = "AI", Category = "MII + SE",   Value = 75.0),
data.frame(Group = "AI", Category = "MID + ME",    Value = 43.1),
data.frame(Group = "AI", Category = "SI + ME", Value = 23.8),
data.frame(Group = "AI", Category = "MID + SE",  Value = 14.4),
data.frame(Group = "AI", Category = "SI + SE",  Value = 0.00),
# Sustainability Group
data.frame(Group = "Sustainability", Category = "MII + ME",   Value = 74.9),
data.frame(Group = "Sustainability", Category = "MII + SE",   Value = 26.1),
data.frame(Group = "Sustainability", Category = "MID + SE",  Value = 8.8),
data.frame(Group = "Sustainability", Category = "MID + ME",    Value = 24.0),
data.frame(Group = "Sustainability", Category = "SI + ME", Value = 4.0),
data.frame(Group = "Sustainability", Category = "SI + SE",  Value = 0.00),
# Management Group
data.frame(Group = "Management", Category = "MII + ME",   Value = 49.4),
data.frame(Group = "Management", Category = "MII + SE",   Value = 30.2),
data.frame(Group = "Management", Category = "MID + ME",    Value = 20.4),
data.frame(Group = "Management", Category = "MID + SE",  Value = 8.80),
data.frame(Group = "Management", Category = "SI + SE",  Value = 0.00),
data.frame(Group = "Management", Category = "SI + ME", Value = -6.6),
# Quantum Group
data.frame(Group = "Quantum", Category = "MII + ME",   Value = 77.5),
data.frame(Group = "Quantum", Category = "MID + ME",    Value = 42.5),
data.frame(Group = "Quantum", Category = "MII + SE",   Value = 36.2),
data.frame(Group = "Quantum", Category = "MID + SE",  Value = 21.4),
data.frame(Group = "Quantum", Category = "SI + ME", Value = 20.8),
data.frame(Group = "Quantum", Category = "SI + SE",  Value = 0.00),
# Wellbeing Group
data.frame(Group = "Wellbeing", Category = "MII + ME",   Value = 44.9),
data.frame(Group = "Wellbeing", Category = "MII + SE",   Value = 32.9),
data.frame(Group = "Wellbeing", Category = "MID + ME",    Value = 18.5),
data.frame(Group = "Wellbeing", Category = "SI + ME", Value = 30.9),
data.frame(Group = "Wellbeing", Category = "SI + SE",  Value = 0.00),
data.frame(Group = "Wellbeing", Category = "MID + SE",  Value = -6.7)
)
# 2. Logic to Sort Bars Independently Per Panel
# We set the Group order first so the panels appear in the correct grid positions
data$Group <- factor(data$Group, levels = c("Space", "AI", "Sustainability",
"Management", "Quantum", "Wellbeing"))
# We create a combined column (Group + Category).
# We then order this column based on the Value (descending).
# This "tricks" ggplot into sorting every panel individually.
data <- data %>%
arrange(Group, desc(Value)) %>%
mutate(Unique_Bar_ID = factor(paste(Group, Category, sep="_"),
levels = paste(Group, Category, sep="_")))
# 3. Define Exact Colors
custom_colors <- c(
"MII + ME"   = "#2ca02c",  # Green
"MII + SE"   = "#d62728",  # Red
"MID + ME"    = "#1f77b4",  # Blue
"MID + SE"  = "#ff7f0e",  # Orange
"SI + ME" = "#9467bd",  # Purple
"SI + SE"  = "#8c564b"   # Brown
)
# 4. Create the Plot
p <- ggplot(data, aes(x = Unique_Bar_ID, y = Value, fill = Category)) +
geom_bar(stat = "identity", width = 0.7) +
# Labels on top of bars
geom_text(aes(label = paste0("+", format(Value, nsmall=2), "%")),
vjust = -0.4,
size = 2.8,
fontface = "bold") +
# Create the 2x3 Grid
facet_wrap(~ Group, scales = "free_x", ncol = 3) +
# Apply Colors
scale_fill_manual(values = custom_colors) +
# Fix X-axis labels (Remove the hidden 'Group_' prefix we added for sorting)
scale_x_discrete(labels = function(x) sub(".*_", "", x)) +
# Labels and Theme
labs(y = "(Top 10% / Total) / (SI + SE Top 10% / SI + SE Total)", x = "") +
theme_bw() +
theme(
# Panel titles (Strip)
strip.background = element_rect(fill = "white", color = NA),
strip.text = element_text(face = "bold", size = 10, hjust = 0),
# Grid lines (Horizontal mainly, lighter vertical)
panel.grid.major.x = element_line(color = "gray95"),
panel.grid.major.y = element_line(color = "gray85"),
panel.grid.minor = element_blank(),
# Axis Text
axis.text.x = element_text(angle = 45, hjust = 1, size = 9, color = "black"),
axis.title = element_text(size = 9, face = "bold"),
# Legend
legend.position = "none" # Hidden as requested by visual match
) +
# Expand Y axis slightly to fit the labels on top
scale_y_continuous(expand = expansion(mult = c(0, 0.15)))
# Display
print(p)
library(ggplot2)
library(dplyr)
# 1. Exact Data Entry
# Values extracted directly from the labels in the high-res image
data <- bind_rows(
# Space Group
data.frame(Group = "Space", Category = "MII + ME",   Value = 62.9),
data.frame(Group = "Space", Category = "MID + ME",    Value = 20.2),
data.frame(Group = "Space", Category = "MII + SE",   Value = 13.6),
data.frame(Group = "Space", Category = "SI + ME", Value = 18.2),
data.frame(Group = "Space", Category = "SI + SE",  Value = 0.00),
data.frame(Group = "Space", Category = "MID + SE",  Value = -11.42),
# AI Group
data.frame(Group = "AI", Category = "MII + ME",   Value = 99.3),
data.frame(Group = "AI", Category = "MII + SE",   Value = 75.0),
data.frame(Group = "AI", Category = "MID + ME",    Value = 43.1),
data.frame(Group = "AI", Category = "SI + ME", Value = 23.8),
data.frame(Group = "AI", Category = "MID + SE",  Value = 14.4),
data.frame(Group = "AI", Category = "SI + SE",  Value = 0.00),
# Sustainability Group
data.frame(Group = "Sustainability", Category = "MII + ME",   Value = 74.9),
data.frame(Group = "Sustainability", Category = "MII + SE",   Value = 26.1),
data.frame(Group = "Sustainability", Category = "MID + SE",  Value = 8.8),
data.frame(Group = "Sustainability", Category = "MID + ME",    Value = 24.0),
data.frame(Group = "Sustainability", Category = "SI + ME", Value = 4.0),
data.frame(Group = "Sustainability", Category = "SI + SE",  Value = 0.00),
# Management Group
data.frame(Group = "Management", Category = "MII + ME",   Value = 49.4),
data.frame(Group = "Management", Category = "MII + SE",   Value = 30.2),
data.frame(Group = "Management", Category = "MID + ME",    Value = 20.4),
data.frame(Group = "Management", Category = "MID + SE",  Value = 8.80),
data.frame(Group = "Management", Category = "SI + SE",  Value = 0.00),
data.frame(Group = "Management", Category = "SI + ME", Value = -6.6),
# Quantum Group
data.frame(Group = "Quantum", Category = "MII + ME",   Value = 77.5),
data.frame(Group = "Quantum", Category = "MID + ME",    Value = 42.5),
data.frame(Group = "Quantum", Category = "MII + SE",   Value = 36.2),
data.frame(Group = "Quantum", Category = "MID + SE",  Value = 21.4),
data.frame(Group = "Quantum", Category = "SI + ME", Value = 20.8),
data.frame(Group = "Quantum", Category = "SI + SE",  Value = 0.00),
# Wellbeing Group
data.frame(Group = "Wellbeing", Category = "MII + ME",   Value = 44.9),
data.frame(Group = "Wellbeing", Category = "MII + SE",   Value = 32.9),
data.frame(Group = "Wellbeing", Category = "MID + ME",    Value = 18.5),
data.frame(Group = "Wellbeing", Category = "SI + ME", Value = 30.9),
data.frame(Group = "Wellbeing", Category = "SI + SE",  Value = 0.00),
data.frame(Group = "Wellbeing", Category = "MID + SE",  Value = -6.7)
)
# 2. Logic to Sort Bars Independently Per Panel
# We set the Group order first so the panels appear in the correct grid positions
data$Group <- factor(data$Group, levels = c("Space", "AI", "Sustainability",
"Management", "Quantum", "Wellbeing"))
# We create a combined column (Group + Category).
# We then order this column based on the Value (descending).
# This "tricks" ggplot into sorting every panel individually.
data <- data %>%
arrange(Group, desc(Value)) %>%
mutate(Unique_Bar_ID = factor(paste(Group, Category, sep="_"),
levels = paste(Group, Category, sep="_")))
# 3. Define Exact Colors
custom_colors <- c(
"MII + ME"   = "#2ca02c",  # Green
"MII + SE"   = "#d62728",  # Red
"MID + ME"    = "#1f77b4",  # Blue
"MID + SE"  = "#ff7f0e",  # Orange
"SI + ME" = "#9467bd",  # Purple
"SI + SE"  = "#8c564b"   # Brown
)
# 4. Create the Plot
p <- ggplot(data, aes(x = Unique_Bar_ID, y = Value, fill = Category)) +
geom_bar(stat = "identity", width = 0.7) +
# Labels on top of bars
geom_text(aes(label = paste0("+", format(Value, nsmall=2), "%")),
vjust = -0.4,
size = 2.8,
fontface = "bold") +
# Create the 2x3 Grid
facet_wrap(~ Group, scales = "free_x", ncol = 3) +
# Apply Colors
scale_fill_manual(values = custom_colors) +
# Fix X-axis labels (Remove the hidden 'Group_' prefix we added for sorting)
scale_x_discrete(labels = function(x) sub(".*_", "", x)) +
# Labels and Theme
labs(y = "Avg Citations / Avg Citations (SI + SE)", x = "") +
theme_bw() +
theme(
# Panel titles (Strip)
strip.background = element_rect(fill = "white", color = NA),
strip.text = element_text(face = "bold", size = 10, hjust = 0),
# Grid lines (Horizontal mainly, lighter vertical)
panel.grid.major.x = element_line(color = "gray95"),
panel.grid.major.y = element_line(color = "gray85"),
panel.grid.minor = element_blank(),
# Axis Text
axis.text.x = element_text(angle = 45, hjust = 1, size = 9, color = "black"),
axis.title = element_text(size = 9, face = "bold"),
# Legend
legend.position = "none" # Hidden as requested by visual match
) +
# Expand Y axis slightly to fit the labels on top
scale_y_continuous(expand = expansion(mult = c(0, 0.15)))
# Display
print(p)
library(readr)
labels <- read_csv("~/Desktop/labelled_results - Sheet2.csv")
View(labels)
library(caret)
library(dplyr)
library(tools)
# 1. Load Data
# Ensure "labels.csv" is in your working directory
#library(readr)
#labels <- read_csv("~/Desktop/labelled_results - Sheet2.csv")
#df <- read.csv("labels.csv", check.names = FALSE, stringsAsFactors = FALSE)
df <- labels
# Select relevant columns
cols <- c("gemini", "openAI-nano", "openAI-35", "human")
df <- df[, cols]
# 2. Preprocessing
# Fill NAs with "Unknown", trim whitespace, and standardize capitalization
df[is.na(df)] <- "Unknown"
for(col in cols) {
df[[col]] <- toTitleCase(trimws(df[[col]]))
}
# Create a unified set of factor levels to ensure all confusion matrices are square
# This includes all unique labels found in any of the columns
all_levels <- sort(unique(unlist(df)))
# Convert all columns to factors with the same levels
for(col in cols) {
df[[col]] <- factor(df[[col]], levels = all_levels)
}
# Function to calculate Cramér's V
calc_cramers_v <- function(x, y) {
# Create contingency table
tbl <- table(x, y)
# Chi-squared statistic
# suppressWarnings is used because small sample sizes can trigger warnings in approximation
chi2 <- suppressWarnings(chisq.test(tbl, correct = FALSE))$statistic
n <- sum(tbl)
k <- min(nrow(tbl), ncol(tbl))
if (k < 2) return(0)
# Formula: V = sqrt(chi2 / (n * (k - 1)))
v <- sqrt(chi2 / (n * (k - 1)))
return(as.numeric(v))
}
# Compute Correlation Matrix
cramer_matrix <- matrix(NA, nrow = 4, ncol = 4, dimnames = list(cols, cols))
View(df)
for(i in cols) {
for(j in cols) {
if(i == j) {
cramer_matrix[i, j] <- 1.0
} else {
cramer_matrix[i, j] <- calc_cramers_v(df[[i]], df[[j]])
}
}
}
cat("\n--- 1. Cramér's V Correlation Matrix ---\n")
print(round(cramer_matrix, 3))
df <- labels
# Select relevant columns
cols <- c("gemini", "openAI-nano", "openAI-35", "human")
df <- df[, cols]
# 2. Preprocessing
# Fill NAs with "Unknown", trim whitespace, and standardize capitalization
df[is.na(df)] <- "Unknown"
for(col in cols) {
df[[col]] <- toTitleCase(trimws(df[[col]]))
}
# Create a unified set of factor levels to ensure confusion matrices work later
all_levels <- sort(unique(unlist(df)))
# Convert all columns to factors with the same levels
for(col in cols) {
df[[col]] <- factor(df[[col]], levels = all_levels)
}
# Function to calculate Cramér's V
calc_cramers_v <- function(x, y) {
# FIX: Drop unused levels for this specific pair to avoid zero-sum rows/cols
x <- droplevels(x)
y <- droplevels(y)
# Create contingency table
tbl <- table(x, y)
# Check dimensions
n <- sum(tbl)
k <- min(nrow(tbl), ncol(tbl))
# If there's less than 2 categories in common, correlation is 0
if (k < 2) return(0)
# Chi-squared statistic
chi2 <- suppressWarnings(chisq.test(tbl, correct = FALSE))$statistic
# Formula: V = sqrt(chi2 / (n * (k - 1)))
v <- sqrt(chi2 / (n * (k - 1)))
return(as.numeric(v))
}
# Compute Correlation Matrix
cramer_matrix <- matrix(NA, nrow = 4, ncol = 4, dimnames = list(cols, cols))
for(i in cols) {
for(j in cols) {
if(i == j) {
cramer_matrix[i, j] <- 1.0
} else {
cramer_matrix[i, j] <- calc_cramers_v(df[[i]], df[[j]])
}
}
}
cat("\n--- 1. Cramér's V Correlation Matrix ---\n")
print(round(cramer_matrix, 3))
models <- c("gemini", "openAI-nano", "openAI-35")
ground_truth <- df$human
metrics_df <- data.frame(
Model = character(),
Accuracy = numeric(),
Precision_Weighted = numeric(),
Recall_Weighted = numeric(),
F1_Weighted = numeric(),
stringsAsFactors = FALSE
)
gt_support <- table(ground_truth)
for(model in models) {
pred <- df[[model]]
cm <- confusionMatrix(data = pred, reference = ground_truth, mode = "prec_recall")
acc <- cm$overall["Accuracy"]
by_class <- cm$byClass
by_class[is.na(by_class)] <- 0
class_names <- gsub("Class: ", "", rownames(by_class))
weights <- gt_support[class_names]
weights[is.na(weights)] <- 0
prec_w <- weighted.mean(by_class[, "Precision"], w = weights)
rec_w  <- weighted.mean(by_class[, "Recall"],    w = weights)
f1_w   <- weighted.mean(by_class[, "F1"],        w = weights)
metrics_df[nrow(metrics_df) + 1, ] <- c(
model,
round(acc, 4),
round(prec_w, 4),
round(rec_w, 4),
round(f1_w, 4)
)
}
cat("\n--- 2. Classification Metrics (Human as Ground Truth) ---\n")
print(metrics_df)
recall_matrix <- matrix(
NA,
nrow = length(all_levels),
ncol = length(models),
dimnames = list(all_levels, models)
)
for(model in models) {
cm <- confusionMatrix(df[[model]], ground_truth, mode = "prec_recall")
by_class <- cm$byClass
by_class[is.na(by_class)] <- 0
class_rows <- gsub("Class: ", "", rownames(by_class))
recall_matrix[class_rows, model] <- by_class[, "Recall"]
}
valid_gt_classes <- names(gt_support)[gt_support > 0]
recall_matrix_filtered <- recall_matrix[valid_gt_classes, ]
cat("\n--- 3. Match Percentage per Ethnicity (Recall) ---\n")
print(round(recall_matrix_filtered * 100, 2))
# 3. Compute Accuracy
models <- c("gemini", "openAI-nano", "openAI-35")
ground_truth <- df$human
# Create an empty dataframe for results
accuracy_table <- data.frame(
Model = character(),
Accuracy = character(), # Character type to hold the "%" string
stringsAsFactors = FALSE
)
# Loop through each model to calculate accuracy
for(model_col in models) {
# Calculate simple accuracy: (Number of Exact Matches) / (Total Rows)
acc_value <- mean(df[[model_col]] == ground_truth)
# Format names for the final table (Mapping CSV headers to Display names)
display_name <- switch(model_col,
"gemini"      = "Gemini",
"openAI-nano" = "OpenAI-Nano",
"openAI-35"   = "OpenAI-3.5"
)
# Format as percentage with 1 decimal place
acc_percent <- paste0(sprintf("%.1f", acc_value * 100), "%")
# Append to dataframe
accuracy_table[nrow(accuracy_table) + 1, ] <- c(display_name, acc_percent)
}
# 4. Print the Final Table
cat("\n--- 3.2. Overall Match Percentage (Accuracy) ---\n")
print(accuracy_table, row.names = FALSE)
